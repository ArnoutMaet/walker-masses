## representing a single atomic structure

A key component of any molecular simulation engine is the ability to represent a collection of atoms in 3D space, 
also referred to as an atomic geometry.
It refers to a list of atoms, whereby each atom is characterized by its position in space, its chemical identity, and, if available, a force which acts on the atom.
In addition, atomic geometries can also contain metadata such as information on their periodicity (unit cell vectors), the potential energy, a stress tensor, or the value of a particular order parameter.

In psiflow, atomic geometries are represented using the `Geometry` class. It is essentially a concise equivalent to ASE's `Atoms` class. They can be created from an XYZ string, from an existing ASE atoms instance, or directly with raw arrays of positions, atomic numbers, and optionally the periodicity.
```py
import ase
import numpy as np
from psiflow.geometry import Geometry


# a simple H2 molecule in vacuum
geometry = Geometry.from_string('''
    2
    H 0.0 0.0 0.0
    H 0.0 0.0 0.8
''')

# the same H2 molecule using ase Atoms
atoms = ase.Atoms(
            numbers=[1, 1, 1],
            positions=[[0, 0, 0], [0, 0, 0.8]],
            pbc=False,
            )
geometry = Geometry.from_atoms(atoms)  # creates an identical instance

print(len(geometry))                   # prints the number of atoms, in this case 2
assert geometry.pbc == False           # if no cell info is given, the instance is assumed to be non-periodic
geometry.cell[:] = 10 * np.eye(3)      # set the cell vectors to a 10 A x 10 A x 10 A cube
assert geometry.pbc == True            # now the instance is periodic


print(geometry.energy)                    # None; no energy has been set
print(np.all(np.isnan(geometry.forces)))  # True; no forces have been set


# the same instance, directly from numpy
geometry = Geometry.from_data(
          positions=np.array([[0, 0, 0], [0, 0, 0.8]]),
          numbers=np.array([1, 1]),
          cell=None,
          )

```

All features in psiflow are fully compatible with either nonperiodic (molecular) or 3D periodic systems with arbitrary unit cells (i.e. general triclinic). However, for efficiency reasons, i-PI (along with OpenMM, GROMACS, and a bunch of other packages) typically require that atomic geometries are represented in their *canonical* orientation.
In the canonical orientation, the cell vectors are aligned with the X, Y, and Z axes as much as possible.
In addition, box vectors are added and subtracted in order to make the cell as orthorhombic as possible.
Note that the relative orientation of atoms with respect to each other as well as the volume of the unit cell remain exactly the same, so this transformation does not affect the physical behavior of the system in any way.
Since psiflow relies on i-PI for sampling, we adhere to the same convention.

```py
geometry = Geometry.from_data(
          positions=np.array([[0, 0, 0], [0, 0, 0.8]]),
          numbers=np.array([1, 1]),
          cell=np.array([[4, 0, 0], [0, 4, 0], [3, 3, 6]]),
          )
geometry.canonical_orientation()  # first and second vector are subtracted from the third
print(geometry.cell)              # the cell vectors are mostly aligned with the axes
```
Check out the API reference for a full overview of its functionality.


## representing multiple structures

In many cases, it is necessary to represent a collection of atomic configurations, for example, a trajectory of snapshots generated by molecular dynamics, or a dataset of atomic configurations used for model training.
In psiflow, such collections are represented using the `Dataset` class.

Importantly, because psiflow supports large-scale asynchronous execution, the `Dataset` instance does not actually store the atomic configurations themselves, but rather just maintains a reference to an XYZ file which is stored on disk.
As such, `Dataset` can represent data which is currently already available (i.e. written in the XYZ file) or *data that will be generated and saved in the future*.

!!! note "Parsl 101: Apps and Futures"
    To understand what is meant by 'generating data in the future', it is necessary
    to introduce the core concepts in Parsl: apps and futures. In their simplest
    form, apps are just functions, and futures are the result of an app given
    a set of inputs. Importantly, a Future already exists before the actual calculation
    is performed. In essence, a Future _promises_ that, at some time in the future, it will
    contain the actual result of the function evaluation. Take a look at the following
    example:

    ```py
    from parsl.app.app import python_app


    @python_app # convert a regular Python function into a Parsl app
    def sum_integers(a, b):
        return a + b


    sum_future = sum_integers(3, 4) # tell Parsl to generate a future that represents the sum of integers 3 and 4
    print(sum_future)               # is an AppFuture, not an integer

    print(sum_future.result())      # now compute the actual result; this will print 7 !

    ```
    The return value of Parsl apps is not the actual result (in this case, an integer), but
    an AppFuture that will store the result of the function evaluation after it has completed.
    The main reason for doing things this way is that this allows for asynchronous execution.
    For more information, check out the [Parsl documentation](https://parsl.readthedocs.io/en/stable/).

Practically speaking, `Dataset` instances behave like a regular list of geometries except that they return Parsl futures:

```py
from psiflow.data import Dataset

data = Dataset.load('trajectory.xyz')     # some trajectory data generated before

data[4]           # AppFuture representing the `Geometry` instance at index 4
data.length()     # AppFuture representing the length of the dataset

```
As shown in the example, you can still index the dataset and ask for its length as you would normally do when working directly with a Python list.
The difference is that `Dataset` does not actually return the values (since they might not be available yet), but rather returns Parsl futures that represent the values.
As a user, you can still interact with the dataset as if it were a regular list, but you will need to call the `.result()` method to get the actual values -- see the [Parsl documentation](https://parsl.readthedocs.io/en/stable/) for more information.

```py
print(data[4].result())         #  actual `Geometry` instance at index 4
print(data.length().result())   #  actual length of the dataset, i.e. the number of states in `train.xyz`
```

Datasets support all the operations that you would expect from a regular list, such as slicing, appending, or concatenating. In addition, they provide a number of convenience methods for common operations, such as filtering, shuffling, or splitting the dataset into training and validation sets.
```py
train, valid = data.split(0.9, shuffle=True)  # do a randomized 90/10 split

energies = train.get('energy')                # get the energies of all geometries in the training set
print(energies.result().shape)                # energies is an AppFuture, so we need to call .result()
# (n,)

forces = train.get('forces')                  # get the forces of all geometries in the training set
print(forces.result().shape)                  # forces is an AppFuture, so we need to call .result()
# (n, 3)
```
